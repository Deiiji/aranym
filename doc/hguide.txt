1st step to Hacker's Guide
--------------------------

0) Content
----------
1) Types
2) Interaction with memory
3) Exceptions
4) HW emulation
5) Emulated opcode
6) Native features
7) Sources
8) debuggers



1) Types
--------

  In "sysdeps.h" there are declared platform independent integer types:

int8     - signed 8 bit
uint8    - unsigned 8 bit
int16    - signed 16 bit
uint16   - unsigned 16 bit
int32    - signed 32 bit
uint32   - unsigned 32 bit
int64    - signed 64 bit
uint64   - unsigned 64 bit

uintptr  - unsigned type with size of (void *)
intptr   - signed type with size of (void *)

memptr   - this type represents Atari's pointer

  For compatibility between ARAnyM and UAE CPU there are declared also these
types:

uae_s8   ~ int8
uae_u8   ~ uint8
uae_s16  ~ int16
uae_u16  ~ uint16
uae_s32  ~ int32
uae_u32  ~ uint32
uae_s64  ~ int64
uae_u64  ~ uint64

uaecptr  - this type represents Atari's pointer

  These types are only for interaction with CPU core. It is better to use
uintXX/intXX types than uae_XXX types.

  For compatibility between ARAnyM and Bochs IDE emulation there are declared
also these types:

Bit8u   ~ uint8
Bit16u  ~ uint16
Bit32u  ~ uint32

  These types are only for internal IDE emulation, not for ARAnyM.

2) Interaction with memory
--------------------------

  For interaction with memory there are six functions declared in
"cpu_emulation.h", three for reading, three for writing:

uint32 ReadAtariInt32(uint32 addr)
uint16 ReadAtariInt16(uint32 addr)
uint8 ReadAtariInt8(uint32 addr)

void WriteAtariInt32(uint32 addr, uint32 l)
void WriteAtariInt16(uint32 addr, uint16 w)
void WriteAtariInt8(uint32 addr, uint8 b)

  These functions have direct access to memory space. They ignore all settings
of CPU (inclusive of MMU). All functions for an emulation of HW (DMA) in
ARAnyM must become only physical addresses, not logical.
  For all emulations of SW, there are another six functions declared in the
same place:

uint32 ReadInt32(uint32 addr)
uint16 ReadInt16(uint32 addr)
uint8 ReadInt8(uint32 addr)

void WriteInt32(uint32 addr, uint32 l)
void WriteInt16(uint32 addr, uint16 w)
void WriteInt8(uint32 addr, uint8 b)

  If you want to use underlying memory (memory allocated in HW I/O address
space), you can use special, quick functions (they don't make any checking):

uint32 ReadHWMemInt32(uint32 addr)
uint16 ReadHWMemInt16(uint32 addr)
uint8 ReadHWMemInt8(uint32 addr)

void WriteHWMemInt32(uint32 addr, uint32 l)
void WriteHWMemInt16(uint32 addr, uint16 w)
void WriteHWMemInt8(uint32 addr, uint8 b)

  If you want make some large operations in ST-RAM or FastRAM, you can use two
functions for address validation:

The 1st is for non-MMU access:

bool ValidAtariAddr(uint32 addr, bool write, uint32 len)

  You can use ReadHWMemIntXX and WriteHWMemIntXX after this function for
ST-RAM and FastRAM with no problems. It doesn't check HW registers!

The 2nd is for MMU access:

bool ValidAddr(uint32 addr, bool write, uint32 len) 
  
  This function is secure only for len = 1, 2 or 4!


3) Exceptions
-------------

  If you want to generate some Exception, it can be done with this sample code:

regs.mmu_fault_addr = addr;
longjmp(excep_env, No. of Exception);


4) HW emulation
---------------

  In ARAnyM there are two possibilities how to emulate HW - old, classic,
Motorola's - to use HW address space mapped to RAM address space and the
second, which needs special drivers - to use emulated opcode. For the second
possibility look at sections 5th and 6th of these guide.
  If you want to write new emulated "HW" from original Atari computers for
ARAnyM you must use older (but better) access for it - mapped address space.
For inspiration look at "hardware.cpp" and e.g. "mmu.cpp".


5) Emulated opcode
------------------

  For implementation of ARAnyM's specific HW, which cannot be supported by any
emulator of Atari computer, you can use one opcode from 0x71XX. Look at
"emul_op.cpp".


6) Native features
------------------
  HW (or better functions) which are "emulator-independent" can use Native
features. In progress.

7) Sources
--------------
CPU:

BasiliskII (CVS 9.4.2002)
BasiliskII JIT (25.3.2002)
AmigaXL (Amithlon, AmigaOSXL) (12.6.2001)
hatari (CVS 2.2.2002)
UAE 0.8.21
MMU patch 2 against 0.8.20 


IDE:

Bochs (CVS 11.5.2002)


8) debuggers
------------
ARAnyM has three different debuggers:

a) uae     - based on UAE's debugger, most portable
b) ndebug
c) mon     - based on BasiliskII's monitor, it isn't included in ARAnyM's
             sources, you could download it from CVS

                 anoncvs@down.physik.uni-mainz.de:/cvs

You can select a debugger with ./configure script.
There are some functions and macros defined in debug.h for debugger output.

